{"entries":[{"timestamp":1756056853176,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":0,"diffs":[[1,"\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":180,"length1":109,"diffs":[[1,"        \"assets.json\"\n"]]}]},{"type":"added","filename":"background.ts","value":"enum BackgroundAlignments {\n    //% block=\"left\"\n    Left = 1,\n    //% block=\"right\"\n    Right,\n    //% block=\"top\"\n    Top,\n    //% block=\"bottom\"\n    Bottom,\n    //% block=\"center\"\n    Center\n}\n\nnamespace scenes {\n    export class Background {\n        color: number;\n        _image: Image;\n        camera: Camera;\n        private _layers: BackgroundLayer[];\n\n        constructor(camera: Camera) {\n            this.color = 0;\n            this.camera = camera;\n            this._layers = [];\n        }\n\n        public addLayer(pic: Image, distance: number, alignment: BackgroundAlignment) {\n            const layer = new BackgroundLayer(distance, alignment, pic);\n            this._layers.push(layer);\n            this._layers.sort((a, b) => b.distance - a.distance);\n            return layer;\n        }\n\n        get image() {\n            if (!this._image) {\n                this._image = image.create(screen.width, screen.height);\n            }\n            return this._image;\n        }\n\n        set image(image: Image) {\n            this._image = image;\n        }\n\n        hasBackgroundImage(): boolean {\n            return !!this._image;\n        }\n\n        draw() {\n            screen.fill(this.color);\n            if (this._image)\n                screen.drawTransparentImage(this._image, 0, 0)\n            if (this._layers) {\n                this._layers.forEach(layer => {\n                    // compute displacement based on distance\n                    const ox = Math.round(this.camera.drawOffsetX / (1 + layer.distance));\n                    const oy = Math.round(this.camera.drawOffsetY / (1 + layer.distance));\n                    layer.draw(ox, oy);\n                });\n            }\n        }\n    }\n\n\n    export class BackgroundLayer {\n        distance: number;\n        img: Image;\n        repeatX: boolean;\n        repeatY: boolean;\n        alignX: BackgroundAlignment;\n        alignY: BackgroundAlignment;\n\n        constructor(distance: number, alignment: BackgroundAlignment, img: Image) {\n            this.distance = Math.max(1, distance);\n            this.img = img;\n            switch (alignment) {\n                case BackgroundAlignment.Center:\n                    this.repeatX = true;\n                    this.repeatY = true;\n                    this.alignX = BackgroundAlignment.Center;\n                    this.alignY = BackgroundAlignment.Center;\n                    break;\n                case BackgroundAlignment.Left:\n                case BackgroundAlignment.Right:\n                    this.repeatX = false;\n                    this.repeatY = true;\n                    this.alignX = alignment;\n                    this.alignY = BackgroundAlignment.Center;\n                    break;\n                case BackgroundAlignment.Top:\n                case BackgroundAlignment.Bottom:\n                    this.repeatX = true;\n                    this.repeatY = false;\n                    this.alignX = BackgroundAlignment.Center;\n                    this.alignY = alignment;\n                    break;\n            }\n        }\n\n        draw(offsetX: number, offsetY: number) {\n            const w = screen.width;\n            const h = screen.height;\n            const pw = this.img.width;\n            const ph = this.img.height;\n\n            if (!pw || !ph) return; // empty image.\n\n            // left, top aligned\n            let rx = -offsetX;\n            let ry = -offsetY;\n\n            switch (this.alignX) {\n                case BackgroundAlignment.Right: rx -= (w + pw); break;\n                case BackgroundAlignment.Center: rx -= (w + pw) >> 1; break;\n            }\n            switch (this.alignY) {\n                case BackgroundAlignment.Bottom: ry -= (h + ph); break;\n                case BackgroundAlignment.Center: ry -= (h + ph) >> 1; break;\n            }\n\n            rx %= w; if (rx < 0) rx += w;\n            ry %= h; if (ry < 0) ry += h;\n\n            // avoid subpixel aliasing\n            rx = Math.floor(rx);\n            ry = Math.floor(ry);\n\n            let y = 0;\n            let py = 0;\n            while (y < h) {\n                py = y % ph;\n                let dh = Math.min(ph - py, h - ry);\n                let x = 0;\n                let rxl = rx;\n                while (x < w) {\n                    let px = x % pw;\n                    let dw = Math.min(pw - px, w - rxl);\n                    screen.drawImage(this.img, rxl, ry);\n                    rxl = (rxl + dw) % w;\n                    x += this.repeatX ? dw : w;\n                }\n                ry = (ry + dh) % h;\n                y += this.repeatY ? dh : h;\n            }\n        }\n    }\n}"},{"type":"added","filename":"camera.ts","value":"namespace scenes {\n    export class Camera {\n        // coordinate used for all physics computation\n        protected _offsetX: number;\n        protected _offsetY: number;\n\n        // coordinate used for draw sprites, may including shaking\n        drawOffsetX: number;\n        drawOffsetY: number;\n        sprite: Sprite;\n        protected _lastUpdatedSpriteX: number;\n        protected _lastUpdatedSpriteY: number;\n\n        protected shakeStartTime: number;\n        protected shakeDuration: number;\n        protected shakeAmplitude: number;\n\n        constructor() {\n            this._offsetX = 0;\n            this._offsetY = 0;\n\n            this.drawOffsetX = 0;\n            this.drawOffsetY = 0;\n        }\n\n        get offsetX() {\n            return this._offsetX;\n        }\n        set offsetX(v: number) {\n            const scene = game.currentScene();\n            if (scene.tileMap && scene.tileMap.enabled) {\n                this._offsetX = Math.floor(scene.tileMap.offsetX(v));\n            } else {\n                this._offsetX = Math.floor(v);\n            }\n        }\n        get offsetY() {\n            return this._offsetY;\n        }\n        set offsetY(v: number) {\n            const scene = game.currentScene();\n            if (scene.tileMap && scene.tileMap.enabled) {\n                this._offsetY = Math.floor(scene.tileMap.offsetY(v));\n            } else {\n                this._offsetY = Math.floor(v);\n            }\n        }\n\n        get x() {\n            return this.offsetX + (screen.width >> 1);\n        }\n        get y() {\n            return this.offsetY + (screen.height >> 1);\n        }\n        get left() {\n            return this.offsetX;\n        }\n        get right() {\n            return this.offsetX + screen.width;\n        }\n        get top() {\n            return this.offsetY;\n        }\n        get bottom() {\n            return this.offsetY + screen.height;\n        }\n\n        shake(amplitude: number = 4, duration: number = 1000) {\n            if (amplitude <= 0 || duration <= 0) {\n                this.shakeStartTime = undefined;\n            } else {\n                // this overrides any existing shake operation\n                this.shakeStartTime = control.millis();\n                this.shakeAmplitude = amplitude;\n                this.shakeDuration = duration;\n                // don't reset offset, will be recomputed in update\n            }\n        }\n\n        isUpdated() {\n            return !this.sprite || (this.sprite.x === this._lastUpdatedSpriteX && this.sprite.y === this._lastUpdatedSpriteY);\n        }\n\n        update() {\n            // if sprite, follow sprite\n            if (this.sprite) {\n                this._lastUpdatedSpriteX = this.sprite.x;\n                this._lastUpdatedSpriteY = this.sprite.y;\n                this.offsetX = this.sprite.left + (this.sprite.width >> 1) - (screen.width >> 1);\n                this.offsetY = this.sprite.top + (this.sprite.width >> 1) - (screen.height >> 1);\n            }\n\n            this.drawOffsetX = this.offsetX;\n            this.drawOffsetY = this.offsetY;\n\n            // apply shake if needed\n            if (this.shakeStartTime !== undefined) {\n                const elapsed = control.millis() - this.shakeStartTime;\n                if (elapsed >= this.shakeDuration) {\n                    // we are done!\n                    this.shakeStartTime = undefined;\n                } else {\n                    // compute new shake\n                    const percentComplete = elapsed / this.shakeDuration;\n                    const dampStart = 0.75;\n                    let damp = 1;\n                    if (percentComplete >= dampStart)\n                        damp = Math.max(0, 1 - percentComplete);\n                    const f = this.shakeAmplitude * damp;\n                    const x = (Math.random() * f) >> 0;\n                    const y = (Math.random() * f) >> 0;\n                    // apply to offset\n                    this.drawOffsetX += x;\n                    this.drawOffsetY += y;\n                }\n            }\n        }\n    }\n}"},{"type":"added","filename":"scene.ts","value":"namespace scenes {\n    export class Scene {\n        background: Background;\n        camera: Camera \n        allSprites: Sprite[]\n\n        constructor () {\n            this.camera = new Camera()\n            this.background = new Background(this.camera)\n            // this.allSprites = [new Sprite(this.image)]\n        }\n    }\n}"},{"type":"added","filename":"scenes.ts","value":"namespace scenes {\n    const _scene = new Scene()\n\n    function init(forceNewScene?: boolean) {\n        if (!_scene || forceNewScene) {\n            _scene = new Scene(control.pushEventContext(), _scene);\n        }\n        _scene.init();\n    }\n}"}]},{"timestamp":1756057450102,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":269,"length1":56,"diffs":[[1,"        \"scenes.ts\"\n"]]}]},{"type":"edited","filename":"scene.ts","patch":[{"start1":19,"length1":753,"diffs":[[1,""]]},{"start1":129,"length1":104,"diffs":[[1,""]]},{"start1":252,"length1":117,"diffs":[[1,"            // this.allSprites = [new Sprite(this.image)]\n"]]},{"start1":320,"length1":1428,"diffs":[[1,""]]}]},{"type":"added","filename":"extenableorbasesprite.ts","value":"\r\n// namespace sprites {\r\n//     export class BaseSprite implements SpriteLike {\r\n//         protected _z: number;\r\n//         id: number;\r\n\r\n//         constructor(z: number) {\r\n//             this.z = z;\r\n\r\n//             // this assigns the sprite an id as a side effect\r\n//             game.currentScene().addSprite(this);\r\n//         }\r\n\r\n//         __visible(): boolean {\r\n//             return true;\r\n//         }\r\n\r\n//         get z(): number {\r\n//             return this._z;\r\n//         }\r\n\r\n//         set z(v: number) {\r\n//             if (this._z !== v) {\r\n//                 this._z = v;\r\n//                 game.currentScene().flags |= scene.Flag.NeedsSorting;\r\n//             }\r\n//         }\r\n\r\n//         __draw(camera: scene.Camera) {\r\n//             if (this.__visible()) {\r\n//                 this.__drawCore(camera);\r\n//             }\r\n//         }\r\n\r\n//         __drawCore(camera: scene.Camera) { }\r\n\r\n//         __update(camera: scene.Camera, dt: number) { }\r\n\r\n//         __serialize(offset: number): Buffer { return undefined }\r\n//     }\r\n// }"}]},{"timestamp":1756058031938,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":133,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><block type=\"pxt-on-start\" x=\"0\" y=\"0\"/></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":1,"diffs":[[1,""]]}]},{"type":"edited","filename":"background.ts","patch":[{"start1":503,"length1":89,"diffs":[[1,"        public addLayer(pic: Image, distance: number, alignment: BackgroundAlignment) {\n"]]},{"start1":1847,"length1":76,"diffs":[[1,"        alignX: BackgroundAlignment;\n        alignY: BackgroundAlignment;\n"]]},{"start1":1922,"length1":85,"diffs":[[1,"        constructor(distance: number, alignment: BackgroundAlignment, img: Image) {\n"]]},{"start1":2118,"length1":50,"diffs":[[1,"                case BackgroundAlignment.Center:\n"]]},{"start1":2249,"length1":126,"diffs":[[1,"                    this.alignX = BackgroundAlignment.Center;\n                    this.alignY = BackgroundAlignment.Center;\n"]]},{"start1":2400,"length1":97,"diffs":[[1,"                case BackgroundAlignment.Left:\n                case BackgroundAlignment.Right:\n"]]},{"start1":2623,"length1":63,"diffs":[[1,"                    this.alignY = BackgroundAlignment.Center;\n"]]},{"start1":2712,"length1":97,"diffs":[[1,"                case BackgroundAlignment.Top:\n                case BackgroundAlignment.Bottom:\n"]]},{"start1":2890,"length1":63,"diffs":[[1,"                    this.alignX = BackgroundAlignment.Center;\n"]]},{"start1":3435,"length1":150,"diffs":[[1,"                case BackgroundAlignment.Right: rx -= (w + pw); break;\n                case BackgroundAlignment.Center: rx -= (w + pw) >> 1; break;\n"]]},{"start1":3632,"length1":151,"diffs":[[1,"                case BackgroundAlignment.Bottom: ry -= (h + ph); break;\n                case BackgroundAlignment.Center: ry -= (h + ph) >> 1; break;\n"]]}]},{"type":"edited","filename":"scene.ts","patch":[{"start1":986,"length1":113,"diffs":[[1,"\n        constructor () {\n"]]},{"start1":2290,"length1":107,"diffs":[[1,"                for (const s of this.allSprites)\n                    s.__update(this.camera, dt);\n"]]},{"start1":2664,"length1":942,"diffs":[[1,""]]},{"start1":2670,"length1":7,"diffs":[[1,"}"]]}]},{"type":"edited","filename":"scenes.ts","patch":[{"start1":19,"length1":22,"diffs":[[1,"    const _scene = new Scene()\n"]]},{"start1":243,"length1":410,"diffs":[[1,""]]}]}]},{"timestamp":1756058628394,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":1433,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":1222,"diffs":[[1,"\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":290,"length1":82,"diffs":[[1,"        \"extenableorbasesprite.ts\"\n"]]}]},{"type":"edited","filename":"scenes.ts","patch":[{"start1":19,"length1":48,"diffs":[[1,"    let _scene: Scene\n"]]},{"start1":42,"length1":656,"diffs":[[1,""]]},{"start1":127,"length1":75,"diffs":[[1,"            _scene = new Scene(control.pushEventContext(), _scene);\n"]]},{"start1":235,"length1":51,"diffs":[[1,"    export function currentScene(): Scene {\n"]]},{"start1":324,"length1":0,"diffs":[[1,"\n    export function backgroundImage () {\n        const backgroundImage = currentScene().background\n        return backgroundImage;\n    }\n    \n    //% blockId=\"\"\n    export function setBackgroundImage (image: Image) {\n        const backgroundImage = currentScene().background\n        backgroundImage.image = image\n    }\n"]]}]},{"type":"added","filename":"ns.ts","value":"//% block=\"scene\" color=\"#249CA3\"\nnamespace scenes {\n\n}"}]},{"timestamp":1756059348723,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"scenes.ts","patch":[{"start1":1020,"length1":617,"diffs":[[1,"}"]]}]}]},{"timestamp":1756059353001,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":19585,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"game_set_background_image\"><value name=\"image\"><shadow type=\"screen_image_picker\"><field name=\"img\">img`\n.............beebbbb............\n............eebbbb4bb...........\n............eb344bb4bb..........\n............e44334bb4bb.........\n............eb433344b4be........\n............4eb43344444be.......\n...........bd4eb43333344bb......\n..........b455d4443333444bb.....\n..........4d5555d444333444bb....\n.........4555555dd4b4443444be...\n........bd5555d555d4bb444444ee..\n........b55ddd665555bb4b44444ee.\n.......bd5555677655554ebb44444eb\n.......43222558855555d4eeb44b4ee\n......b422332ddd555222d4eebbb4be\n......be22232ed55522332db4ebbbbe\n.....bde22222e555e22232edd4bbbbe\n.....b52e222e3555e22222eddd4ebee\n....bd552eee355552e222e355544eee\n....665dd5555555552eee355dd4deee\n...6776555555555555555551554d4ee\n...4885222555dddd6655551544d4eee\n..b45522332555dd677611d444ddeee.\n..4d5222232e55555881d44ddd4eee..\n.bdd5e22222e555115114d54d4ee....\n.b55d2e222e351144d1d55eeee......\nbd5ddd2eee3d444555dd4e..........\nb555115dddd55d544eede...........\n4511d444d5544ee...4de...........\n41d4555d4ee........44...........\n41554eede.......................\n44ee...4e.......................\n"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":31,"length1":19800,"diffs":[[1,"    .............beebbbb............\n    ............eebbbb4bb...........\n    ............eb344bb4bb..........\n    ............e44334bb4bb.........\n    ............eb433344b4be........\n    ............4eb43344444be.......\n    ...........bd4eb43333344bb......\n    ..........b455d4443333444bb.....\n    ..........4d5555d444333444bb....\n    .........4555555dd4b4443444be...\n    ........bd5555d555d4bb444444ee..\n    ........b55ddd665555bb4b44444ee.\n    .......bd5555677655554ebb44444eb\n    .......43222558855555d4eeb44b4ee\n    ......b422332ddd555222d4eebbb4be\n    ......be22232ed55522332db4ebbbbe\n    .....bde22222e555e22232edd4bbbbe\n    .....b52e222e3555e22222eddd4ebee\n    ....bd552eee355552e222e355544eee\n    ....665dd5555555552eee355dd4deee\n    ...6776555555555555555551554d4ee\n    ...4885222555dddd6655551544d4eee\n    ..b45522332555dd677611d444ddeee.\n    ..4d5222232e55555881d44ddd4eee..\n    .bdd5e22222e555115114d54d4ee....\n    .b55d2e222e351144d1d55eeee......\n    bd5ddd2eee3d444555dd4e..........\n    b555115dddd55d544eede...........\n    4511d444d5544ee...4de...........\n    41d4555d4ee........44...........\n    41554eede.......................\n    44ee...4e.......................\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":2,"length1":27,"diffs":[[1,"    \"name\": \"background\",\n"]]},{"start1":379,"length1":35,"diffs":[[1,"    \"preferredEditor\": \"tsprj\"\n"]]}]},{"type":"edited","filename":"scene.ts","patch":[{"start1":1008,"length1":1,"diffs":[[1,""]]},{"start1":1099,"length1":349,"diffs":[[1,"            this.camera = new Camera()\n            this.background = new Background(this.camera)\n            this.allSprites = []\n            this.eventContext = control.eventContext()\n            this._millis = 0\n"]]},{"start1":1324,"length1":1,"diffs":[[1,""]]}]},{"type":"edited","filename":"scenes.ts","patch":[{"start1":186,"length1":66,"diffs":[[1,"        const backgroundImage = updatedScene.currentScene().background\n"]]},{"start1":349,"length1":117,"diffs":[[1,"    //% blockId=\"game_set_background_image\" block=\"set background image %image=screen_image_picker\" weight = 100\n"]]},{"start1":518,"length1":55,"diffs":[[1,"        const backgroundImage = updatedScene.currentScene()\n"]]},{"start1":633,"length1":289,"diffs":[[1,""]]},{"start1":1022,"length1":108,"diffs":[[1,""]]},{"start1":1023,"length1":0,"diffs":[[1,"namespace game {\n    let _scene: scene.Scene;\n\n"]]},{"start1":1145,"length1":67,"diffs":[[1,"            _scene = new scene.Scene();\n"]]},{"start1":1229,"length1":51,"diffs":[[1,"    export function currentScene(): scene.Scene {\n"]]},{"start1":1348,"length1":59,"diffs":[[1,"    export function backgroundImage(): scene.Background {\n"]]}]}]},{"timestamp":1756059963141,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":19838,"length1":27,"diffs":[[1,""]]}]}]},{"timestamp":1756059964679,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":539,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"game_set_background_image\"><value name=\"image\"><shadow type=\"background_image_picker\"><field name=\"img\">img`\n"]]},{"start1":19585,"length1":131,"diffs":[[1,"`</field><data>{\"commentRefs\":[],\"fieldData\":{\"img\":null}}</data></shadow></value></block></statement></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":29,"diffs":[[1,""]]},{"start1":19838,"length1":0,"diffs":[[1,"scenes.backgroundColor(10)\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":380,"length1":44,"diffs":[[1,""]]}]},{"type":"edited","filename":"scenes.ts","patch":[{"start1":677,"length1":176,"diffs":[[1,"      //% blockId=\"game_set_background_color\" block=\"background color %color=colorWheelPicker\"\n    export function backgroundColor (color: number) {\n"]]},{"start1":916,"length1":292,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1756056853175,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><block type=\"pxt-on-start\" x=\"0\" y=\"0\"/></xml>","main.ts":"\n","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"background\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1756058655435,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block></xml>","main.ts":"\n","README.md":" ","assets.json":"","background.ts":"enum BackgroundAlignments {\n    //% block=\"left\"\n    Left = 1,\n    //% block=\"right\"\n    Right,\n    //% block=\"top\"\n    Top,\n    //% block=\"bottom\"\n    Bottom,\n    //% block=\"center\"\n    Center\n}\n\nnamespace scenes {\n    export class Background {\n        color: number;\n        _image: Image;\n        camera: Camera;\n        private _layers: BackgroundLayer[];\n\n        constructor(camera: Camera) {\n            this.color = 0;\n            this.camera = camera;\n            this._layers = [];\n        }\n\n        public addLayer(pic: Image, distance: number, alignment: BackgroundAlignments) {\n            const layer = new BackgroundLayer(distance, alignment, pic);\n            this._layers.push(layer);\n            this._layers.sort((a, b) => b.distance - a.distance);\n            return layer;\n        }\n\n        get image() {\n            if (!this._image) {\n                this._image = image.create(screen.width, screen.height);\n            }\n            return this._image;\n        }\n\n        set image(image: Image) {\n            this._image = image;\n        }\n\n        hasBackgroundImage(): boolean {\n            return !!this._image;\n        }\n\n        draw() {\n            screen.fill(this.color);\n            if (this._image)\n                screen.drawTransparentImage(this._image, 0, 0)\n            if (this._layers) {\n                this._layers.forEach(layer => {\n                    // compute displacement based on distance\n                    const ox = Math.round(this.camera.drawOffsetX / (1 + layer.distance));\n                    const oy = Math.round(this.camera.drawOffsetY / (1 + layer.distance));\n                    layer.draw(ox, oy);\n                });\n            }\n        }\n    }\n\n\n    export class BackgroundLayer {\n        distance: number;\n        img: Image;\n        repeatX: boolean;\n        repeatY: boolean;\n        alignX: BackgroundAlignments;\n        alignY: BackgroundAlignments;\n\n        constructor(distance: number, alignment: BackgroundAlignments, img: Image) {\n            this.distance = Math.max(1, distance);\n            this.img = img;\n            switch (alignment) {\n                case BackgroundAlignments.Center:\n                    this.repeatX = true;\n                    this.repeatY = true;\n                    this.alignX = BackgroundAlignments.Center;\n                    this.alignY = BackgroundAlignments.Center;\n                    break;\n                case BackgroundAlignments.Left:\n                case BackgroundAlignments.Right:\n                    this.repeatX = false;\n                    this.repeatY = true;\n                    this.alignX = alignment;\n                    this.alignY = BackgroundAlignments.Center;\n                    break;\n                case BackgroundAlignments.Top:\n                case BackgroundAlignments.Bottom:\n                    this.repeatX = true;\n                    this.repeatY = false;\n                    this.alignX = BackgroundAlignments.Center;\n                    this.alignY = alignment;\n                    break;\n            }\n        }\n\n        draw(offsetX: number, offsetY: number) {\n            const w = screen.width;\n            const h = screen.height;\n            const pw = this.img.width;\n            const ph = this.img.height;\n\n            if (!pw || !ph) return; // empty image.\n\n            // left, top aligned\n            let rx = -offsetX;\n            let ry = -offsetY;\n\n            switch (this.alignX) {\n                case BackgroundAlignments.Right: rx -= (w + pw); break;\n                case BackgroundAlignments.Center: rx -= (w + pw) >> 1; break;\n            }\n            switch (this.alignY) {\n                case BackgroundAlignments.Bottom: ry -= (h + ph); break;\n                case BackgroundAlignments.Center: ry -= (h + ph) >> 1; break;\n            }\n\n            rx %= w; if (rx < 0) rx += w;\n            ry %= h; if (ry < 0) ry += h;\n\n            // avoid subpixel aliasing\n            rx = Math.floor(rx);\n            ry = Math.floor(ry);\n\n            let y = 0;\n            let py = 0;\n            while (y < h) {\n                py = y % ph;\n                let dh = Math.min(ph - py, h - ry);\n                let x = 0;\n                let rxl = rx;\n                while (x < w) {\n                    let px = x % pw;\n                    let dw = Math.min(pw - px, w - rxl);\n                    screen.drawImage(this.img, rxl, ry);\n                    rxl = (rxl + dw) % w;\n                    x += this.repeatX ? dw : w;\n                }\n                ry = (ry + dh) % h;\n                y += this.repeatY ? dh : h;\n            }\n        }\n    }\n}","camera.ts":"namespace scenes {\n    export class Camera {\n        // coordinate used for all physics computation\n        protected _offsetX: number;\n        protected _offsetY: number;\n\n        // coordinate used for draw sprites, may including shaking\n        drawOffsetX: number;\n        drawOffsetY: number;\n        sprite: Sprite;\n        protected _lastUpdatedSpriteX: number;\n        protected _lastUpdatedSpriteY: number;\n\n        protected shakeStartTime: number;\n        protected shakeDuration: number;\n        protected shakeAmplitude: number;\n\n        constructor() {\n            this._offsetX = 0;\n            this._offsetY = 0;\n\n            this.drawOffsetX = 0;\n            this.drawOffsetY = 0;\n        }\n\n        get offsetX() {\n            return this._offsetX;\n        }\n        set offsetX(v: number) {\n            const scene = game.currentScene();\n            if (scene.tileMap && scene.tileMap.enabled) {\n                this._offsetX = Math.floor(scene.tileMap.offsetX(v));\n            } else {\n                this._offsetX = Math.floor(v);\n            }\n        }\n        get offsetY() {\n            return this._offsetY;\n        }\n        set offsetY(v: number) {\n            const scene = game.currentScene();\n            if (scene.tileMap && scene.tileMap.enabled) {\n                this._offsetY = Math.floor(scene.tileMap.offsetY(v));\n            } else {\n                this._offsetY = Math.floor(v);\n            }\n        }\n\n        get x() {\n            return this.offsetX + (screen.width >> 1);\n        }\n        get y() {\n            return this.offsetY + (screen.height >> 1);\n        }\n        get left() {\n            return this.offsetX;\n        }\n        get right() {\n            return this.offsetX + screen.width;\n        }\n        get top() {\n            return this.offsetY;\n        }\n        get bottom() {\n            return this.offsetY + screen.height;\n        }\n\n        shake(amplitude: number = 4, duration: number = 1000) {\n            if (amplitude <= 0 || duration <= 0) {\n                this.shakeStartTime = undefined;\n            } else {\n                // this overrides any existing shake operation\n                this.shakeStartTime = control.millis();\n                this.shakeAmplitude = amplitude;\n                this.shakeDuration = duration;\n                // don't reset offset, will be recomputed in update\n            }\n        }\n\n        isUpdated() {\n            return !this.sprite || (this.sprite.x === this._lastUpdatedSpriteX && this.sprite.y === this._lastUpdatedSpriteY);\n        }\n\n        update() {\n            // if sprite, follow sprite\n            if (this.sprite) {\n                this._lastUpdatedSpriteX = this.sprite.x;\n                this._lastUpdatedSpriteY = this.sprite.y;\n                this.offsetX = this.sprite.left + (this.sprite.width >> 1) - (screen.width >> 1);\n                this.offsetY = this.sprite.top + (this.sprite.width >> 1) - (screen.height >> 1);\n            }\n\n            this.drawOffsetX = this.offsetX;\n            this.drawOffsetY = this.offsetY;\n\n            // apply shake if needed\n            if (this.shakeStartTime !== undefined) {\n                const elapsed = control.millis() - this.shakeStartTime;\n                if (elapsed >= this.shakeDuration) {\n                    // we are done!\n                    this.shakeStartTime = undefined;\n                } else {\n                    // compute new shake\n                    const percentComplete = elapsed / this.shakeDuration;\n                    const dampStart = 0.75;\n                    let damp = 1;\n                    if (percentComplete >= dampStart)\n                        damp = Math.max(0, 1 - percentComplete);\n                    const f = this.shakeAmplitude * damp;\n                    const x = (Math.random() * f) >> 0;\n                    const y = (Math.random() * f) >> 0;\n                    // apply to offset\n                    this.drawOffsetX += x;\n                    this.drawOffsetY += y;\n                }\n            }\n        }\n    }\n}","scene.ts":"namespace scenes {\n    // frame handler priorities\n    export const CONTROLLER_PRIORITY = 8;\n    export const UPDATE_CONTROLLER_PRIORITY = 13;\n    export const FOLLOW_SPRITE_PRIORITY = 14;\n    export const PHYSICS_PRIORITY = 15;\n    export const ANIMATION_UPDATE_PRIORITY = 15;\n    export const CONTROLLER_SPRITES_PRIORITY = 13;\n    export const UPDATE_INTERVAL_PRIORITY = 19;\n    export const UPDATE_PRIORITY = 20;\n    export const PRE_RENDER_UPDATE_PRIORITY = 55;\n    export const RENDER_BACKGROUND_PRIORITY = 60;\n    export const RENDER_SPRITES_PRIORITY = 90;\n    export const RENDER_DIAGNOSTICS_PRIORITY = 150;\n    export const MULTIPLAYER_SCREEN_PRIORITY = 190;\n    export const UPDATE_SCREEN_PRIORITY = 200;\n    export const MULTIPLAYER_POST_SCREEN_PRIORITY = 210;\n\n    export class Scene {\n        background: Background;\n        camera: Camera \n        allSprites: Sprite[]\n        eventContext: control.EventContext\n        _millis: number\n        physicsEngine: PhysicsEngine\n        flags: number\n        constructor(eventcontext: control.EventContext, protected previousScene?: Scene) {\n            this.camera = new Camera()\n            this.background = new Background(this.camera)\n            this.allSprites = []\n            this.eventContext = control.eventContext()\n            this._millis = 0\n        }\n\n        init () {\n            this.eventContext.registerFrameHandler(CONTROLLER_PRIORITY, () => {\n                this._millis += this.eventContext.deltaTimeMillis;\n                control.enablePerfCounter(\"controller_update\")\n                controller.__update(this.eventContext.deltaTime);\n            })\n            // controller update 13\n            this.eventContext.registerFrameHandler(CONTROLLER_SPRITES_PRIORITY, controller._moveSprites);\n            // sprite following 14\n            // apply physics and collisions 15\n            this.eventContext.registerFrameHandler(PHYSICS_PRIORITY, () => {\n                control.enablePerfCounter(\"physics and collisions\")\n                this.physicsEngine.move(this.eventContext.deltaTime);\n            });\n            // user update interval 19s\n\n            // user update 20\n\n            // prerender update 55\n            this.eventContext.registerFrameHandler(PRE_RENDER_UPDATE_PRIORITY, () => {\n                const dt = this.eventContext.deltaTime;\n                this.camera.update();\n\n                // for (const s of this.allSprites)\n                //     // s.__update(this.camera, dt);\n            })\n\n            // render background 60\n\n            // render 90\n            this.eventContext.registerFrameHandler(RENDER_SPRITES_PRIORITY, () => {\n                control.enablePerfCounter(\"scene_draw\");\n                this.render();\n            });\n        }\n\n        render() {\n            // bail out from recursive or parallel call.\n            if (this.flags & scene.Flag.IsRendering) return;\n            this.flags |= scene.Flag.IsRendering;\n\n            control.enablePerfCounter(\"render background\")\n            if ((this.flags & scene.Flag.SeeThrough) && this.previousScene) {\n                this.previousScene.render();\n            } else {\n                this.background.draw();\n            }\n\n            control.enablePerfCounter(\"sprite sort\")\n            if (this.flags & scene.Flag.NeedsSorting) {\n                this.allSprites.sort(function (a, b) { return a.z - b.z || a.id - b.id; })\n                this.flags &= ~scene.Flag.NeedsSorting;\n            }\n\n            control.enablePerfCounter(\"sprite draw\")\n            // for (const s of this.allSprites) {\n            //     s.__draw(this.camera);\n            // }\n\n            this.flags &= ~scene.Flag.IsRendering;\n        }\n    }\n\n    }\n","scenes.ts":"namespace scenes {\n    let _scene: Scene\n\n    function init(forceNewScene?: boolean) {\n        if (!_scene || forceNewScene) {\n            _scene = new Scene(control.pushEventContext(), _scene);\n        }\n        _scene.init();\n    }\n\n    export function currentScene(): Scene {\n        init();\n        return _scene;\n    }\n\n    export function backgroundImage () {\n        const backgroundImage = currentScene().background\n        return backgroundImage;\n    }\n    \n    //% blockId=\"game_set_background_image\" block=\"set background image %image=\"\n    export function setBackgroundImage (image: Image) {\n        const backgroundImage = currentScene().background\n        backgroundImage.image = image\n    }\n}","extenableorbasesprite.ts":"\r\n// namespace sprites {\r\n//     export class BaseSprite implements SpriteLike {\r\n//         protected _z: number;\r\n//         id: number;\r\n\r\n//         constructor(z: number) {\r\n//             this.z = z;\r\n\r\n//             // this assigns the sprite an id as a side effect\r\n//             game.currentScene().addSprite(this);\r\n//         }\r\n\r\n//         __visible(): boolean {\r\n//             return true;\r\n//         }\r\n\r\n//         get z(): number {\r\n//             return this._z;\r\n//         }\r\n\r\n//         set z(v: number) {\r\n//             if (this._z !== v) {\r\n//                 this._z = v;\r\n//                 game.currentScene().flags |= scene.Flag.NeedsSorting;\r\n//             }\r\n//         }\r\n\r\n//         __draw(camera: scene.Camera) {\r\n//             if (this.__visible()) {\r\n//                 this.__drawCore(camera);\r\n//             }\r\n//         }\r\n\r\n//         __drawCore(camera: scene.Camera) { }\r\n\r\n//         __update(camera: scene.Camera, dt: number) { }\r\n\r\n//         __serialize(offset: number): Buffer { return undefined }\r\n//     }\r\n// }","pxt.json":"{\n    \"name\": \"background\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"background.ts\",\n        \"camera.ts\",\n        \"scene.ts\",\n        \"scenes.ts\",\n        \"extenableorbasesprite.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1756060313308}